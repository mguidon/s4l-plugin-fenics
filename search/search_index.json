{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sim4Life FEniCS Plugin Documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The FEniCS solver in this plugin provides a modular finite element simulation backend for Sim4Life. It leverages the FEniCS finite element library to solve a wide range of partial differential equations (PDEs) defined within the Sim4Life environment. The solver supports stationary (steady-state), eigenvalue, and time-domain (transient) simulations, making it suitable for a variety of physical modeling tasks.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>General PDE Solving: Supports the solution of general PDEs using the finite element method.</li> <li>Multiple Simulation Types: Handles stationary, eigenvalue, and time-domain problems.</li> <li>Sim4Life Integration: Reads simulation definitions, meshes, and boundary conditions exported from Sim4Life.</li> <li>Automated Workflow: Imports mesh and model data, assembles variational forms, applies boundary conditions, solves the problem, and exports results for visualization.</li> <li>Extensible Design: Modular structure allows for easy extension with new equations, boundary conditions, and post-processing routines.</li> <li>Real and Complex Problems: Supports both real-valued and complex-valued simulations, enabling a wide range of physical applications.</li> </ul>"},{"location":"#workflow-overview","title":"Workflow Overview","text":"<ol> <li>Input Preparation: Simulation definitions and mesh data are exported from Sim4Life as JSON and VTU files.</li> <li>Solver Initialization: The main solver script loads the input, prepares the mesh, and sets up the problem.</li> <li>Problem Assembly: Function spaces, variational forms, and boundary conditions are created based on the user-defined model.</li> <li>Solving: The appropriate solver is selected based on the simulation type (stationary, eigenvalue, or time-domain).</li> <li>Result Export: Simulation results are written to VTK files for visualization and further analysis.</li> </ol> <p>This design enables users to run complex finite element simulations within Sim4Life, while benefiting from the flexibility and power of the FEniCS library.</p>"},{"location":"#seamless-postprocessing-integration","title":"Seamless Postprocessing Integration","text":"<p>Simulation results produced by the FEniCS solver are fully compatible with the Sim4Life postprocessing pipeline. Results can be directly viewed, inspected, and analyzed using the integrated Sim4Life viewers, allowing for efficient visualization and further analysis without additional conversion steps.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Example 1: Poisson Equation on a Unit Square</li> <li>Example 2: Linear Elasticity in 2D</li> <li>Example 3: Heat Equation (Transient)</li> <li>Example 4: Laplace Equation on a Circle</li> </ul> <p>Explore each example for ready-to-use simulation setups and meshes.</p>"},{"location":"examples/harmonic_oscillator/","title":"Quantum Harmonic Oscillator: Eigenvalues","text":"<p>This example demonstrates how to compute the eigenvalues (energy states) of a quantum harmonic oscillator using the FEniCS plugin in Sim4Life. The setup and results can be loaded directly into Sim4Life using the <code>.smash</code> and <code>.sims</code> files in the <code>files</code> subfolder.</p>"},{"location":"examples/harmonic_oscillator/#physics-background","title":"Physics Background","text":"<p>The quantum harmonic oscillator is a fundamental model in quantum mechanics, describing a particle subject to a restoring force proportional to its displacement. The time-independent Schr\u00f6dinger equation (TISE) for the 1D harmonic oscillator is:</p> \\[ -\\frac{1}{2} \\nabla^2 \\phi_i + \\frac{1}{2} x^2 \\phi_i = E_i \\phi_i \\] <p>where \\(\\phi_i\\) is the \\(i\\)-th eigenfunction and \\(E_i\\) the corresponding eigenvalue (energy level). Here, we use dimensionless units by scaling energy by \\(\\hbar\\omega\\) and \\(x\\) by \\(\\sqrt{\\hbar/(m\\omega)}\\).</p> <p>The analytical solution for the energy levels is:</p> \\[ E_n = \\hbar\\omega\\left(n + \\frac{1}{2}\\right) \\]"},{"location":"examples/harmonic_oscillator/#mapping-to-the-weak-form","title":"Mapping to the Weak Form","text":"<p>The FEniCS plugin solves the weak form of the eigenvalue problem:</p> \\[ \\int_\\Omega \\left(\\frac{1}{2} \\nabla \\phi_i \\cdot \\nabla v + \\frac{1}{2} x^2 \\phi_i v\\right) dx = E_i \\int_\\Omega \\phi_i v \\, dx \\] <p>where \\(v\\) is a test function. This is set up in the plugin by specifying the diffusion and linear terms, and selecting the eigenvalue solver mode.</p>"},{"location":"examples/harmonic_oscillator/#model-setup","title":"Model Setup","text":"<p>The computational domain is a 1D or 2D region representing the oscillator potential. The mesh and subdomain assignments are shown below:</p> <p></p>"},{"location":"examples/harmonic_oscillator/#simulation-setup","title":"Simulation Setup","text":""},{"location":"examples/harmonic_oscillator/#1-simulation-settings","title":"1. Simulation Settings","text":"<ul> <li>Simulation Type: Eigenvalue</li> </ul>"},{"location":"examples/harmonic_oscillator/#2-solver-settings","title":"2. Solver Settings","text":"<ul> <li>Solver Type: Eigenvalue (e.g., SLEPc)</li> <li>Number of Eigenvalues: (as set in the UI)</li> </ul>"},{"location":"examples/harmonic_oscillator/#3-global-expressions","title":"3. Global Expressions","text":"<p>Global expressions can be used to define parameters, but for this example, the potential is hardcoded as \\(0.5 x^2\\).</p> <p></p>"},{"location":"examples/harmonic_oscillator/#4-equation","title":"4. Equation","text":"<p>The equation settings specify the eigenvalue problem for the wave function \\(\\phi_i\\).</p> <p></p>"},{"location":"examples/harmonic_oscillator/#5-subdomain-settings","title":"5. Subdomain Settings","text":"<p>The entire domain uses the same physics: kinetic and potential terms as described above.</p> <p></p>"},{"location":"examples/harmonic_oscillator/#6-dirichlet-boundary-conditions","title":"6. Dirichlet Boundary Conditions","text":"<p>Dirichlet boundary conditions are applied to the domain boundaries: - Boundary Value: \\(0\\) (the wave function vanishes at the edges)</p> <p></p>"},{"location":"examples/harmonic_oscillator/#how-the-physics-is-mapped","title":"How the Physics is Mapped","text":"<ul> <li>Diffusion coefficient: \\(0.5\\) (for the kinetic term \\(-\\frac{1}{2} \\nabla^2 \\phi\\))</li> <li>Linear term: \\(0.5 x^2\\) (for the potential energy)</li> <li>The plugin constructs the weak form and solves for the lowest eigenvalues and eigenfunctions.</li> </ul>"},{"location":"examples/harmonic_oscillator/#running-the-simulation","title":"Running the Simulation","text":"<ol> <li>Set up the geometry and physics as shown above.</li> <li>Configure the solver and boundary conditions.</li> <li>Run the simulation in eigenvalue mode.</li> </ol>"},{"location":"examples/harmonic_oscillator/#results","title":"Results","text":"<p>The simulation computes the lowest energy eigenvalues and eigenfunctions of the quantum harmonic oscillator. The animation below shows the eigenfunctions visualized with the slice field viewer:</p> <p></p>"},{"location":"examples/harmonic_oscillator/#references","title":"References","text":"<ul> <li>FEniCS Project</li> <li>Quantum Harmonic Oscillator (Wikiversity)</li> </ul>"},{"location":"examples/quantum_tunneling/","title":"Quantum Tunneling","text":"<p>This example can be loaded directly into Sim4Life by uploading the provided <code>.smash</code> and <code>.sims</code> files from the <code>files</code> subfolder. To do this, use the burger menu in the Sim4Life user interface and select the <code>.smash</code> file to load the complete example setup.</p> <p>This example demonstrates how to simulate quantum tunneling using the FEniCS plugin in Sim4Life. The setup models a Gaussian wave packet incident on a potential barrier, illustrating the fundamental quantum phenomenon of tunneling.</p>"},{"location":"examples/quantum_tunneling/#physics-background","title":"Physics Background","text":"<p>Quantum tunneling is a phenomenon where a quantum particle can pass through a potential barrier even if its energy is less than the barrier height. This is governed by the time-dependent Schr\u00f6dinger equation:</p> \\[ i \\frac{\\partial u}{\\partial t} = -\\frac{1}{2} \\nabla^2 u + V(x) u \\] <p>where \\(u(x, t)\\) is the wave function and \\(V(x)\\) is the potential (nonzero in the barrier region).</p>"},{"location":"examples/quantum_tunneling/#model-setup","title":"Model Setup","text":"<p>The computational domain is modeled as a rectangle, subdivided into two main regions: a central barrier and surrounding free space. This allows us to represent a potential barrier in the middle of the domain, with free propagation regions on either side. The mesh and subdomain assignments are shown below:</p> <p></p>"},{"location":"examples/quantum_tunneling/#simulation-setup","title":"Simulation Setup","text":""},{"location":"examples/quantum_tunneling/#1-simulation-settings","title":"1. Simulation Settings","text":"<p>We use the Time-Domain as the simulation type for this example.</p> <p></p>"},{"location":"examples/quantum_tunneling/#2-solver-settings","title":"2. Solver Settings","text":"<ul> <li>Field Type: Complex</li> <li>Solver Type: Linear (Direct LU)</li> <li>Time Domain Solver:</li> <li>Method: LobattoIIIA (Runge-Kutta)</li> <li>Stages: 3</li> <li>Initial Time Step: 0.001</li> <li>Max Time Step: 1</li> <li>Duration: 0.15</li> </ul>"},{"location":"examples/quantum_tunneling/#3-global-expressions","title":"3. Global Expressions","text":"<p>Global expressions define the physical parameters used in the simulation: - <code>k0 = 20</code> (wavenumber of the initial wave packet) - <code>E0 = 0.5*k0**2</code> (energy of the wave packet) - <code>DV = 10</code> (potential barrier height)</p> <p></p>"},{"location":"examples/quantum_tunneling/#4-equation","title":"4. Equation","text":"<p>The time-dependent Schr\u00f6dinger equation is solved for the wave function \\(u\\).</p> <ul> <li>Initial Condition: <code>python   ufl.exp(1j*x[1]*k0)*ufl.exp(-ufl.inner(x,x)/(2*0.5**2))</code>   This represents a Gaussian wave packet with wavenumber <code>k0</code>.</li> </ul> <p></p>"},{"location":"examples/quantum_tunneling/#5-free-space","title":"5. Free Space","text":"<ul> <li>Diffusion Coefficient: <code>-1/(2j)</code> (kinetic term)</li> <li>Linear Term: <code>0</code> (no potential in free space)</li> </ul>"},{"location":"examples/quantum_tunneling/#6-barrier","title":"6. Barrier","text":"<ul> <li>Diffusion Coefficient: <code>-1/(2j)</code> (kinetic term)</li> <li>Linear Term: <code>(E0 + DV)/(1j)</code> (potential energy in the barrier)</li> </ul>"},{"location":"examples/quantum_tunneling/#7-dirichlet-boundary-conditions","title":"7. Dirichlet Boundary Conditions","text":"<p>A Dirichlet boundary condition is applied: - Boundary Value: <code>0</code> (the wave function is set to zero on the specified boundary)</p> <p></p>"},{"location":"examples/quantum_tunneling/#how-the-physics-is-mapped","title":"How the Physics is Mapped","text":"<ul> <li>The diffusion coefficient \\(-1/(2j)\\) implements the kinetic term \\(-\\frac{1}{2} \\nabla^2 u\\).</li> <li>The linear term in the barrier region adds the potential energy.</li> <li>The weak form is constructed automatically by the plugin, following the variational principle.</li> </ul>"},{"location":"examples/quantum_tunneling/#running-the-simulation","title":"Running the Simulation","text":"<ol> <li>Set up the geometry and physics as shown above.</li> <li>Configure the solver and boundary conditions.</li> <li>Run the simulation in time-domain mode.</li> </ol> <p>The solver output will show progress through time steps and confirm successful completion.</p>"},{"location":"examples/quantum_tunneling/#results","title":"Results","text":"<p>The simulation produces the time evolution of the wave function, showing both reflection and tunneling through the barrier.</p> <p></p> <p>The results can be interactively inspected and visualized using the built-in viewers in Sim4Life, allowing you to explore the wave function dynamics over time.</p>"},{"location":"examples/quantum_tunneling/#references","title":"References","text":"<ul> <li>FEniCS Project</li> <li>Wikipedia</li> </ul>"},{"location":"examples/stokes_flow/","title":"Stokes Flow Past a Sphere","text":"<p>This example demonstrates how to simulate steady Stokes flow past a sphere using the FEniCS plugin in Sim4Life. The setup and results can be loaded directly into Sim4Life using the provided mesh and simulation setup files.</p>"},{"location":"examples/stokes_flow/#physics-background","title":"Physics Background","text":"<p>Stokes flow describes the motion of a viscous, incompressible fluid at low Reynolds numbers, where inertial forces are negligible compared to viscous forces. The governing equations are:</p> \\[ -\\mu \\nabla^2 \\mathbf{u} + \\nabla p = 0 \\\\ \\nabla \\cdot \\mathbf{u} = 0 \\] <p>where \\(\\mathbf{u}\\) is the velocity field, \\(p\\) is the pressure, and \\(\\mu\\) is the dynamic viscosity.</p>"},{"location":"examples/stokes_flow/#mapping-to-the-weak-form","title":"Mapping to the Weak Form","text":"<p>The FEniCS plugin solves the weak form of the Stokes equations. For test functions \\(\\mathbf{v}\\) (velocity) and \\(q\\) (pressure):</p> \\[ \\int_\\Omega \\nabla \\mathbf{u} : \\nabla \\mathbf{v} \\, dx - \\int_\\Omega p \\, \\nabla \\cdot \\mathbf{v} \\, dx + \\int_\\Omega q \\, \\nabla \\cdot \\mathbf{u} \\, dx = 0 \\] <p>This is implemented in the plugin by adding the following bilinear form in the subdomain settings for \\(\\mathbf{u}\\):</p> <pre><code>ufl.inner(ufl.grad(u), ufl.grad(u_test)) - ufl.div(u_test) * p + p_test * ufl.div(u)\n</code></pre> <p>where: - <code>u</code> is the velocity trial function (\\(\\mathbf{u}\\)) - <code>u_test</code> is the velocity test function (\\(\\mathbf{v}\\)) - <code>p</code> is the pressure trial function (\\(p\\)) - <code>p_test</code> is the pressure test function (\\(q\\))</p> <p>This directly corresponds to the weak form above, with each term mapping as follows: - <code>ufl.inner(ufl.grad(u), ufl.grad(u_test))</code> \\(\\rightarrow\\) \\(\\int_\\Omega \\nabla \\mathbf{u} : \\nabla \\mathbf{v} \\, dx\\) - <code>- ufl.div(u_test) * p</code> \\(\\rightarrow\\) \\(-\\int_\\Omega p \\, \\nabla \\cdot \\mathbf{v} \\, dx\\) - <code>p_test * ufl.div(u)</code> \\(\\rightarrow\\) \\(\\int_\\Omega q \\, \\nabla \\cdot \\mathbf{u} \\, dx\\)</p>"},{"location":"examples/stokes_flow/#model-setup","title":"Model Setup","text":"<p>The computational domain consists of a sphere embedded in a rectangular box, representing the fluid region around the sphere. The mesh and subdomain assignments are shown below:</p> <p></p>"},{"location":"examples/stokes_flow/#simulation-setup","title":"Simulation Setup","text":""},{"location":"examples/stokes_flow/#1-simulation-settings","title":"1. Simulation Settings","text":"<ul> <li>Simulation Type: Stationary (steady-state)</li> </ul>"},{"location":"examples/stokes_flow/#2-solver-settings","title":"2. Solver Settings","text":"<ul> <li>Solver Type: Linear (Direct LU)</li> <li>Field Type: Real</li> </ul>"},{"location":"examples/stokes_flow/#equation-and-subdomain-settings","title":"Equation and Subdomain Settings","text":""},{"location":"examples/stokes_flow/#velocity-field-mathbfu","title":"Velocity Field \\(\\mathbf{u}\\)","text":"<ul> <li>Equation:</li> </ul> <ul> <li>Subdomain Settings:</li> </ul> <ul> <li>Dirichlet Boundary Conditions:</li> <li>Inlet (left boundary): \\(\\mathbf{u} = (1, 0, 0)\\) </li> <li>Sphere surface: \\(\\mathbf{u} = (0, 0, 0)\\) (no-slip)     </li> </ul>"},{"location":"examples/stokes_flow/#pressure-field-p","title":"Pressure Field \\(p\\)","text":"<ul> <li>Equation:</li> </ul> <ul> <li>Subdomain Settings:</li> </ul> <ul> <li>Dirichlet Boundary Condition:</li> <li>Outlet (right boundary): \\(p = 0\\) </li> </ul>"},{"location":"examples/stokes_flow/#running-the-simulation","title":"Running the Simulation","text":"<ol> <li>Load the mesh and simulation setup files into Sim4Life.</li> <li>Review and adjust the parameters as needed.</li> <li>Run the simulation to compute the velocity and pressure fields.</li> <li>Visualize the results to observe the flow pattern and pressure distribution around the sphere.</li> </ol>"},{"location":"examples/stokes_flow/#results-visualization","title":"Results Visualization","text":"<p>The figure below shows the velocity distribution around the sphere, visualized in Sim4Life using a combination of a slice field and vector field viewer. This allows you to see both the magnitude and direction of the flow as it moves past the sphere:</p> <p></p>"},{"location":"examples/stokes_flow/#references","title":"References","text":"<ul> <li>Stokes Flow - Wikipedia</li> <li>FEniCS Project Documentation</li> </ul>"}]}